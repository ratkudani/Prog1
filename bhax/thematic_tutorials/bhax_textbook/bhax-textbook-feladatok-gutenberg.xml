<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
            Az elején egy bevezetést kapunk a programozási nyelvek általánosságairól, főleg az alaptani dolgokról, 
            és a típusokról. Háromféle programozási nyelvet különböztetünk meg egymástól. Ez az assembly nyelv, ami úgy 
            ismerhetünk, mint a gépi nyelvhez legközelebb eső és álló programozási nyelv. Másodikként beszélhetünk a 
            gépi nyelvről, és ami a mi esetünkben most a legfontosabb, a magasszintű programozási nyelvek. Az ebben megírt 
            típusú kódok elnevezése a forrás lesz, amíg a nyelvtani szabálykeretrendszert szintaktikai szabályként definiálunk. 
            Először a megírt forrást fordítani kell, hogy az gépi nyelvű legyen, ezáltal megértetve a számítógéppel amit szeretnénk, 
            és majd csak ezután jön a tényleges futtatás. Bevezetésre kerül még az interpreteres módszer is, amely 
            az előzővel ellenben nem készíti el a tárgyprogramot. Rengeteg futtatási környezet van már a világon.
        </para>
        <para>
            Tovvábiakban szó lesz az imperatív nyelvekről és a jelölő rendszerekről. Kezdjünk is bele egyből az előbb 
            említett résszel. Önmagában ez egy olyan algoritmus, ami a processzor működéséért felel, ezáltal kezeli az 
            utasításokat, és eljárásokat is. Emellé megemlítendő a deklaratív nyelv is, amely nem feltétlen 
            hasonló mint az előbbi társa, ugyanis ez eltér a Neumann elvektől. Most pedig elindulhatunk kielemezni az 
            első mondatban említett második főelemet. Szóval, első sorban tisztázzuk, hogy ebből többféle is létezik. 
            Például terminális és akármilyen meglepő is lehet, de a nem terminális is. Ez kiemelendően fontos a szintaktikai 
            szabályok megalkotásához.
        </para>
        <para>
            Előző fejezetek után jött egy elég komoly szakasz, ahol a különböző adattípusokról ejtett szót az író, és 
            hogy ez milyen összetevője is pontosan az általunk ismert programozásnak. Erre példa lehet mondjuk valaminek 
            az értéke. Léteznek absztrakt típusok és alaptípusok. Az elsőt vizsgálva három összetevője van. Első a tartomány, 
            a kapcsolódó műveletek, és a reprezentáció. Az altípussal pedig inkább lekérdezésekhez 
            használjuk, ha valamilyen típus érdekel minket.
        </para>
        <para>
            A soron következő témakör az I/O volt ami az oprendszerrel áll kapcsolatban. Működése során a memóriával foglalatoskodik,
            azan onnak fogad és ad információt, adatot. Rengetek típus van. Karakter, ami lehet 
            string. Egész ami fixpontos, és valós, ami lebegő pontos. Van még logikai, ami lehet igaz és 
            hamis értékű. Ezt az informatikában egyessel és nullással jelöljük. Végül pedig a mutató, ami érték kérő. 
            Név, típus és érték az a három alkotó elem, amely a konstansot nevesítetté teszi.
        </para>
    </section> 
           
           
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            A könyv azzal kezdődik, hogy összefoglalja a C programozási nyelv eredet mítoszát, és annak közeli kapcsolatát a UNIX-xal, ami egy 
            operációs rendszer. Olyan igazságokat foglal magában, mint a C nyelv megtanulásának legjobb módja, ami míly meglepő a gyakorlásban 
            rejlik. Továbbá kifejti mi is a nyelvnek az alap sója és borsa. Ilyen eset például a vezérleti elv, ami a 
            szintaktikát foglalja magába, és kiemeli a ";" végi fontosságot, és a változók bevezetését.
        </para>
        <para>
            Fő felhasználatáról beszél, hogy milyen jól lehet vele operációs rendszerek kidolgozásakor. Folytatólagosan kitér 
            az If függvény működésére, mégpedig hogy ha az If igaz , akkor az jó, ha meg nem, akkor az else ágon lesz a továbbfutása a 
            programnak. Ezután sorra veszi a While ciklust és annak elvét. Kibővíti a Do-While-al, ami addig csinálja az 
            általunk kért folyamatot amíg el nem éri a megint csak általunk meghatározott feltételt. Na meg hát ki ne maradjon a For ciklus se ebből 
            a halomból, így hát róluk is esett szó, amelynek működési elvben nagyban hasonlít a Do-ra.
        </para>
        <para>
            Kiemelődik mi nem elérhető a nyelvben. Például hogy nincs benne objektum, ami akár jó is lehet a szabad forráskód írás tekintetében. 
            Visszatéregetünk az előző fejezetben leírt ciklusok megszakítására és újra folytatására amit a break-kel érhetünk el, az utóbb 
            említettet pedig a continue-val. Végül, az általam kiolvasott utolsó kiadott fejezetben pedig arról kellett kiértékelést adnom az olvasottakról, 
            hogy minek által tudunk kombinált utasítást írni. Ezt a könyv, mint az eddigieket is több bekezdésen keresztül részletesen taglalja a lehető legegyszerűbb és 
            a lehető legtisztább, gyorsabb megértés érdekében. Célja ezzel, hogy egy parancs kiadásával tudjuk többet is futtatni.
        </para>
  </section>
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
            Mint az előzőben, itt is egy programozási nyelv bevezetésről lesz szó, minek által valahogy csak el kell kezdeni egy programozás specifikus 
            könyv megírását. Ebben a könyvben már a C++ magasszintű programozási nyelvről lesz szó, amelyben a magasszintű programozási 1 nevezetű egyetemi 
            második féléves tárgyunk nagyja épült, főleg a feladatcsokrok második felétől indulóan, ahol már szerves részévé vált a kidolgozásunkban. Elkezdi 
            az eredettörténetét, ahol kapcsolatba állítja a C programozási nyelvvel és összeveti az utóbb említett nyelv hasonlóságaival, és az ellentéteivel.
        </para>
        <para>
            A könyv bőszen megemlíti a program formális szabványait, és ezt úgy, hogy több különböző 
            esetre is levetíti. Erre példát statuálhat amikor az alap szabványt említi és amikor argumentumokat is 
            szeretnénk alkalmazni a programunkban a kódolás során. Még megemlítésre kerül egy olyan különbség az elődjével szemben (
            ami a C), hogy itt új típussal is találkozunk, még pedig a bool-al, ami a logikához kapcsolódik, mert ezáltal kreálhatunk 
            mostantól olyan változót, aminek logikai értéke van. Plusz a wchar, ami sok bájt tárolására hasznos, és emiatt is lett létrehozva.
        </para>
        <para>
            Hatalmas újítások közt szerepel még, hogy mostantól az elődjével szemben képes az operátor és függvény túlterhelésre is. 
            Azaz képesek vagyunk arra is, hogy egyazon elnevezésű függvényeket tudjunk használni abban az esetben, ha azok argomentumaikban 
            különböznek egymástól. 
        </para>
        <para>
            Kifejti a referencia típus előnyeit, melyet fokoz a sablonok használatának hasznosságáról. Ezek után jön, hogy 
            mivel is dolgozik maga a nyelv, mégpedig stream és bájt sorozatok tömkelegével. Ámbár ekkor már tudjuk, hogy milyen 
            boilerplate szerepe van az iostream implementálásának a programunkba, ugyanis ezáltal tudunk manipulátorokkal is dolgozni, ami 
            azért elég hasznos. Ezt veti össze hasznosság és produktivitás szempontjából az endl és a setprecision között. Továbbá 
            ehhez szükség van az állománykezeléshez is, amely külső fájlokkal való dolgozást jelenti. Elődjével szembeni másik kiválósága hogy tudunk vele 
            írni és ovlasni is külső forrásból. Az utolsó érdemleges szegmens pedig nem más, mint ami az egyetemi tanulmányaink során a bevezetés a 
            programozásba nevezetű tárgyunkban már szintén szóba került hiba kereséses elkapás, azaz a try-catch nevezetű hiba kiírás. Ennél 
            deklarálnunk kell hogy milyen hibát is keressen és adjon ki.
        </para>
    </section>
</chapter>
